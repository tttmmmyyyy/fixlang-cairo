module Cairo;
import Math::{sin, cos};

type Cairo = unbox struct { _dtor : Destructor CairoHandle };

type CairoHandle = Ptr;

_borrow : (CairoHandle -> a) -> Cairo -> a;
_borrow = |act, cairo| cairo.@_dtor.borrow(act);

_borrow_io : (CairoHandle -> IO a) -> Cairo -> IO a;
_borrow_io = |act, cairo| cairo.@_dtor.borrow_io(act);

create : Surface -> IO Cairo;
create = |surface| (
    surface._borrow_io(|surface| (
        let handle = *FFI_CALL_IO[Ptr cairo_create(Ptr), surface];
        pure $ Cairo { 
            _dtor : Destructor::make(
                handle,
                |handle| FFI_CALL_IO[() cairo_destroy(Ptr), handle];; pure $ handle
            )
        }
    ))
);

status : Cairo -> IO Status;
status = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[I32 cairo_status(Ptr), cairo]
));

save : Cairo -> IO ();
save = |cairo| cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_save(Ptr), cairo]
));

restore : Cairo -> IO ();
restore = |cairo| cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_restore(Ptr), cairo]
));

get_target : Cairo -> IO Surface;
get_target = |cairo| cairo._borrow_io(|cairo| (
    let surface = *FFI_CALL_IO[Ptr cairo_get_target(Ptr), cairo];
    let surface = FFI_CALL[Ptr cairo_surface_reference(Ptr), surface];
    pure $ Surface::_create_from_handle(surface)
));

push_group : Cairo -> IO ();
push_group = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_push_group(Ptr), cairo]
));

push_group_with_content : Content -> Cairo -> IO ();
push_group_with_content = |content, cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_push_group_with_content(Ptr, I32), cairo, content]
));

pop_group : Cairo -> IO Pattern;
pop_group = |cairo| cairo._borrow_io(|cairo| (
    let pattern = *FFI_CALL_IO[Ptr cairo_pop_group(Ptr), cairo];
    pure $ Pattern::_create_from_handle(pattern)
));

pop_group_to_source : Cairo -> IO ();
pop_group_to_source = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_pop_group_to_source(Ptr), cairo]
));

get_group_target : Cairo -> IO Surface;
get_group_target = |cairo| cairo._borrow_io(|cairo| (
    let surface = *FFI_CALL_IO[Ptr cairo_get_group_target(Ptr), cairo];
    let surface = FFI_CALL[Ptr cairo_surface_reference(Ptr), surface];
    pure $ Surface::_create_from_handle(surface)
));

set_source_rgb : (F64, F64, F64) -> Cairo -> IO ();
set_source_rgb = |(r, g, b), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_source_rgb(Ptr, F64, F64, F64), cairo, r, g, b]
    ))
);

set_source_rgba : (F64, F64, F64,F64) -> Cairo -> IO ();
set_source_rgba = |(r, g, b, a), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_source_rgba(Ptr, F64, F64, F64, F64), cairo, r, g, b, a]
    ))
);

set_source : Pattern -> Cairo -> IO ();
set_source = |pattern, cairo| (
    cairo._borrow_io(|cairo| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_set_source(Ptr, Ptr), cairo, pattern]
        ))
    ))
);

set_source_surface : Surface -> (F64, F64) -> Cairo -> IO ();
set_source_surface = |surface, (x, y), cairo| (
    cairo._borrow_io(|cairo| (
        surface._borrow_io(|surface| (
            FFI_CALL_IO[() cairo_set_source_surface(Ptr, Ptr, F64, F64), cairo, surface, x, y]
        ))
    ))
);

get_source : Cairo -> IO Pattern;
get_source = |cairo| cairo._borrow_io(|cairo| (
    let pattern = *FFI_CALL_IO[Ptr cairo_get_source(Ptr), cairo];
    let pattern = FFI_CALL[Ptr cairo_pattern_reference(Ptr), pattern];
    pure $ Pattern::_create_from_handle(pattern)
));

set_antialias : Antialias -> Cairo -> IO ();
set_antialias = |antialias, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_antialias(Ptr, I32), cairo, antialias]
    ))
);

get_antialias : Cairo -> IO Antialias;
get_antialias = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[I32 cairo_get_antialias(Ptr), cairo]
));

set_dash : Array F64 -> F64 -> Cairo -> IO ();
set_dash = |dashes, offset, cairo| (
    cairo._borrow_io(|cairo| ( 
        let num_dashes = dashes.get_size.to_I32;
        dashes.borrow_ptr_io(|dashes| (
            FFI_CALL_IO[() cairo_set_dash(Ptr, Ptr, I32, F64), cairo, dashes, num_dashes, offset]
        ))
    ))
);

get_dash_count : Cairo -> IO I64;
get_dash_count = |cairo| cairo._borrow_io(|cairo| (
    let count = *FFI_CALL_IO[I32 cairo_get_dash_count(Ptr), cairo];
    pure $ count.to_I64
));

get_dash : Cairo -> IO (Array F64, F64);
get_dash = |cairo| (
    let dash_count = *cairo.get_dash_count;
    let dashes : Array F64 = Array::fill(dash_count, 0.0);
    let offset : Array F64 = Array::fill(1, 0.0);
    eval cairo._borrow_io(|cairo| FFI_CALL_IO[() cairo_get_dash(Ptr, Ptr, Ptr), cairo, dashes._get_ptr, offset._get_ptr]);
    pure $ (dashes, offset.@(0))
);

set_fill_rule : FillRule -> Cairo -> IO ();
set_fill_rule = |fill_rule, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_fill_rule(Ptr, I32), cairo, fill_rule]
    ))
);

get_fill_rule : Cairo -> IO FillRule;
get_fill_rule = |cairo| cairo._borrow_io(|cairo| (
    let fill_rule = *FFI_CALL_IO[I32 cairo_get_fill_rule(Ptr), cairo];
    pure $ fill_rule
));

set_line_cap : LineCap -> Cairo -> IO ();
set_line_cap = |line_cap, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_line_cap(Ptr, I32), cairo, line_cap]
    ))
);

get_line_cap : Cairo -> IO LineCap;
get_line_cap = |cairo| cairo._borrow_io(|cairo| (
    let line_cap = *FFI_CALL_IO[I32 cairo_get_line_cap(Ptr), cairo];
    pure $ line_cap
));

set_line_join : LineJoin -> Cairo -> IO ();
set_line_join = |line_join, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_line_join(Ptr, I32), cairo, line_join]
    ))
);

get_line_join : Cairo -> IO LineJoin;
get_line_join = |cairo| cairo._borrow_io(|cairo| (
    let line_join = *FFI_CALL_IO[I32 cairo_get_line_join(Ptr), cairo];
    pure $ line_join
));

set_line_width : F64 -> Cairo -> IO ();
set_line_width = |width, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_line_width(Ptr, F64), cairo, width]
    ))
);

get_line_width : Cairo -> IO F64;
get_line_width = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[F64 cairo_get_line_width(Ptr), cairo]
));

set_miter_limit : F64 -> Cairo -> IO ();
set_miter_limit = |limit, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_miter_limit(Ptr, F64), cairo, limit]
    ))
);

get_miter_limit : Cairo -> IO F64;
get_miter_limit = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[F64 cairo_get_miter_limit(Ptr), cairo]
));

set_operator : Operator -> Cairo -> IO ();
set_operator = |op, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_operator(Ptr, I32), cairo, op]
    ))
);

get_operator : Cairo -> IO Operator;
get_operator = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[I32 cairo_get_operator(Ptr), cairo]
));

set_tolerance : F64 -> Cairo -> IO ();
set_tolerance = |tolerance, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_tolerance(Ptr, F64), cairo, tolerance]
    ))
);

get_tolerance : Cairo -> IO F64;
get_tolerance = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[F64 cairo_get_tolerance(Ptr), cairo]
));

clip : Cairo -> IO ();
clip = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_clip(Ptr), cairo]
));

clip_preserve : Cairo -> IO ();
clip_preserve = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_clip_preserve(Ptr), cairo]
));

clip_extents : Cairo -> IO (F64, F64, F64, F64);
clip_extents = |cairo| cairo._borrow_io(|cairo| 
    let x1 : Array F64 = Array::fill(1, 0.0);
    let y1 : Array F64 = Array::fill(1, 0.0);
    let x2 : Array F64 = Array::fill(1, 0.0);
    let y2 : Array F64 = Array::fill(1, 0.0);
    FFI_CALL_IO[() cairo_clip_extents(Ptr, Ptr, Ptr, Ptr, Ptr), cairo, x1._get_ptr, y1._get_ptr, x2._get_ptr, y2._get_ptr];;
    pure $ (x1.@(0), y1.@(0), x2.@(0), y2.@(0))
);

in_clip : (F64, F64) -> Cairo -> IO Bool;
in_clip = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        let result = *FFI_CALL_IO[I32 cairo_in_clip(Ptr, F64, F64), cairo, x, y];
        pure $ result != 1_I32
    ))
);

reset_clip : Cairo -> IO ();
reset_clip = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_reset_clip(Ptr), cairo]
));

copy_clip_rectangle_list : Cairo -> IO RectangleList;
copy_clip_rectangle_list = |cairo| cairo._borrow_io(|cairo| (
    let list = *FFI_CALL_IO[Ptr cairo_copy_clip_rectangle_list(Ptr), cairo];
    pure $ RectangleList::_create_from_handle(list)
));

fill : Cairo -> IO ();
fill = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_fill(Ptr), cairo]
));

fill_preserve : Cairo -> IO ();
fill_preserve = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_fill_preserve(Ptr), cairo]
));

fill_extents : Cairo -> IO (F64, F64, F64, F64);
fill_extents = |cairo| cairo._borrow_io(|cairo|
    let x1 : Array F64 = Array::fill(1, 0.0);
    let y1 : Array F64 = Array::fill(1, 0.0);
    let x2 : Array F64 = Array::fill(1, 0.0);
    let y2 : Array F64 = Array::fill(1, 0.0);
    FFI_CALL_IO[() cairo_fill_extents(Ptr, Ptr, Ptr, Ptr, Ptr), cairo, x1._get_ptr, y1._get_ptr, x2._get_ptr, y2._get_ptr];;
    pure $ (x1.@(0), y1.@(0), x2.@(0), y2.@(0))
);

in_fill : (F64, F64) -> Cairo -> IO Bool;
in_fill = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        let result = *FFI_CALL_IO[I32 cairo_in_fill(Ptr, F64, F64), cairo, x, y];
        pure $ result != 1_I32
    ))
);

mask : Pattern -> Cairo -> IO ();
mask = |pattern, cairo| (
    cairo._borrow_io(|cairo| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mask(Ptr, Ptr), cairo, pattern]
        ))
    ))
);

mask_surface : Surface -> (F64, F64) -> Cairo -> IO ();
mask_surface = |surface, (x, y), cairo| (
    cairo._borrow_io(|cairo| (
        surface._borrow_io(|surface| (
            FFI_CALL_IO[() cairo_mask_surface(Ptr, Ptr, F64, F64), cairo, surface, x, y]
        ))
    ))
);

paint : Cairo -> IO ();
paint = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_paint(Ptr), cairo]
));

paint_with_alpha : F64 -> Cairo -> IO ();
paint_with_alpha = |alpha, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_paint_with_alpha(Ptr, F64), cairo, alpha]
    ))
);

stroke : Cairo -> IO ();
stroke = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_stroke(Ptr), cairo]
));

stroke_preserve : Cairo -> IO ();
stroke_preserve = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_stroke_preserve(Ptr), cairo]
));

stroke_extents : Cairo -> IO (F64, F64, F64, F64);
stroke_extents = |cairo| cairo._borrow_io(|cairo|
    let x1 : Array F64 = Array::fill(1, 0.0);
    let y1 : Array F64 = Array::fill(1, 0.0);
    let x2 : Array F64 = Array::fill(1, 0.0);
    let y2 : Array F64 = Array::fill(1, 0.0);
    FFI_CALL_IO[() cairo_stroke_extents(Ptr, Ptr, Ptr, Ptr, Ptr), cairo, x1._get_ptr, y1._get_ptr, x2._get_ptr, y2._get_ptr];;
    pure $ (x1.@(0), y1.@(0), x2.@(0), y2.@(0))
);

in_stroke : (F64, F64) -> Cairo -> IO Bool;
in_stroke = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        let result = *FFI_CALL_IO[I32 cairo_in_stroke(Ptr, F64, F64), cairo, x, y];
        pure $ result != 1_I32
    ))
);

copy_page : Cairo -> IO ();
copy_page = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_copy_page(Ptr), cairo]
));

show_page : Cairo -> IO ();
show_page = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_show_page(Ptr), cairo]
));

set_hairline : Bool -> Cairo -> IO ();
set_hairline = |hairline, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_antialias(Ptr, I32), cairo, if hairline { 1_I32 } else { 0_I32 }]
    ))
);

get_hairline : Cairo -> IO Bool;
get_hairline = |cairo| cairo._borrow_io(|cairo| (
    let hairline = *FFI_CALL_IO[I32 cairo_get_hairline(Ptr), cairo];
    pure $ hairline == 1_I32
));

copy_path : Cairo -> IO Cairo::Path;
copy_path = |cairo| cairo._borrow_io(|cairo| (
    let path = *FFI_CALL_IO[Ptr cairo_copy_path(Ptr), cairo];
    pure $ Path::_create_from_handle(path)
));

copy_path_flat : Cairo -> IO Cairo::Path;
copy_path_flat = |cairo| cairo._borrow_io(|cairo| (
    let path = *FFI_CALL_IO[Ptr cairo_copy_path_flat(Ptr), cairo];
    pure $ Path::_create_from_handle(path)
));

append_path : Cairo::Path -> Cairo -> IO ();
append_path = |path, cairo| (
    cairo._borrow_io(|cairo| (
        path._borrow_io(|path| (
            FFI_CALL_IO[() cairo_append_path(Ptr, Ptr), cairo, path]
        ))
    ))
);

has_current_point : Cairo -> IO Bool;
has_current_point = |cairo| (
    cairo._borrow_io(|cairo| (
        let result = *FFI_CALL_IO[I32 cairo_has_current_point(Ptr), cairo];
        pure $ result != 0_I32
    ))
);

get_current_point : Cairo -> IO (F64, F64);
get_current_point = |cairo| cairo._borrow_io(|cairo|
    let x = Boxed { value : 0.0 };
    let y = Boxed { value : 0.0 };
    let (x, (y, _)) = *x.mutate_boxed_io(|x_ptr| y.mutate_boxed_io(|y_ptr|
        FFI_CALL_IO[() cairo_get_current_point(Ptr, Ptr, Ptr), cairo, x_ptr, y_ptr])
    );
    pure $ (x.@value, y.@value)
);

new_path : Cairo -> IO ();
new_path = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_new_path(Ptr), cairo]
));

new_sub_path : Cairo -> IO ();
new_sub_path = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_new_sub_path(Ptr), cairo]
));

close_path : Cairo -> IO ();
close_path = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_close_path(Ptr), cairo]
));

arc : (F64, F64) -> F64 -> F64 -> F64 -> Cairo -> IO ();
arc = |(x, y), radius, angle1, angle2, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_arc(Ptr, F64, F64, F64, F64, F64), cairo, x, y, radius, angle1, angle2]
    ))
);

arc_negative : (F64, F64) -> F64 -> F64 -> F64 -> Cairo -> IO ();
arc_negative = |(x, y), radius, angle1, angle2, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_arc_negative(Ptr, F64, F64, F64, F64, F64), cairo, x, y, radius, angle1, angle2]
    ))
);

curve_to : (F64, F64) -> (F64, F64) -> (F64, F64) -> Cairo -> IO ();
curve_to = |(x1, y1), (x2, y2), (x3, y3), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_curve_to(Ptr, F64, F64, F64, F64, F64, F64), cairo, x1, y1, x2, y2, x3, y3]
    ))
);

line_to : (F64, F64) -> Cairo -> IO ();
line_to = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_line_to(Ptr, F64, F64), cairo, x, y]
    ))
);

move_to : (F64, F64) -> Cairo -> IO ();
move_to = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_move_to(Ptr, F64, F64), cairo, x, y]
    ))
);

rectangle : (F64, F64) -> (F64, F64) -> Cairo -> IO ();
rectangle = |(x, y), (width, height), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_rectangle(Ptr, F64, F64, F64, F64), cairo, x, y, width, height]
    ))
);

glyph_path : Array Glyph -> Cairo -> IO ();
glyph_path = |glyphs, cairo| (
    cairo._borrow_io(|cairo| (
        let num_glyphs = glyphs.get_size.to_I32;
        glyphs.borrow_ptr(|glyphs| (
            FFI_CALL_IO[() cairo_glyph_path(Ptr, Ptr, I32), cairo, glyphs, num_glyphs]
        ))
    ))
);

text_path : String -> Cairo -> IO ();
text_path = |text, cairo| (
    cairo._borrow_io(|cairo| (
        text.borrow_c_str(|text| (
            FFI_CALL_IO[() cairo_text_path(Ptr, Ptr), cairo, text]
        ))
    ))
);

rel_curve_to : (F64, F64) -> (F64, F64) -> (F64, F64) -> Cairo -> IO ();
rel_curve_to = |(dx1, dy1), (dx2, dy2), (dx3, dy3), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_rel_curve_to(Ptr, F64, F64, F64, F64, F64, F64), cairo, dx1, dy1, dx2, dy2, dx3, dy3]
    ))
);

rel_line_to : (F64, F64) -> Cairo -> IO ();
rel_line_to = |(dx, dy), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_rel_line_to(Ptr, F64, F64), cairo, dx, dy]
    ))
);

rel_move_to : (F64, F64) -> Cairo -> IO ();
rel_move_to = |(dx, dy), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_rel_move_to(Ptr, F64, F64), cairo, dx, dy]
    ))
);

path_extents : Cairo -> IO (F64, F64, F64, F64);
path_extents = |cairo| cairo._borrow_io(|cairo|
    let x1 = Boxed { value : 0.0 };
    let y1 = Boxed { value : 0.0 };
    let x2 = Boxed { value : 0.0 };
    let y2 = Boxed { value : 0.0 };
    let (x1, (y1, (x2, (y2, _)))) = *x1.mutate_boxed_io(|x1_ptr| y1.mutate_boxed_io(|y1_ptr| x2.mutate_boxed_io(|x2_ptr| y2.mutate_boxed_io(|y2_ptr| 
        FFI_CALL_IO[() cairo_path_extents(Ptr, Ptr, Ptr, Ptr, Ptr), cairo, x1_ptr, y1_ptr, x2_ptr, y2_ptr]
    ))));
    pure $ (x1.@value, y1.@value, x2.@value, y2.@value)
);

translate : (F64, F64) -> Cairo -> IO ();
translate = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_translate(Ptr, F64, F64), cairo, x, y]
    ))
);

scale : (F64, F64) -> Cairo -> IO ();
scale = |(x, y), cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_scale(Ptr, F64, F64), cairo, x, y]
    ))
);

rotate : F64 -> Cairo -> IO ();
rotate = |angle, cairo| (
    cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_rotate(Ptr, F64), cairo, angle]
    ))
);

transform : Matrix -> Cairo -> IO ();
transform = |matrix, cairo| (
    cairo._borrow_io(|cairo| (
        matrix._with_ptr_io(|matrix| (
            FFI_CALL_IO[() cairo_transform(Ptr, Ptr), cairo, matrix]
        ))
    ))
);

set_matrix : Matrix -> Cairo -> IO ();
set_matrix = |matrix, cairo| (
    cairo._borrow_io(|cairo| (
        matrix._with_ptr_io(|matrix| (
            FFI_CALL_IO[() cairo_set_matrix(Ptr, Ptr), cairo, matrix]
        ))
    ))
);

get_matrix : Cairo -> IO Matrix;
get_matrix = |cairo| cairo._borrow_io(|cairo| (
    let matrix = Matrix::init_identity;
    let (matrix, _) = *matrix._mutate_io(|matrix| (
        FFI_CALL_IO[() cairo_get_matrix(Ptr, Ptr), cairo, matrix]
    ));
    pure $ matrix
));

identity_matrix : Cairo -> IO ();
identity_matrix = |cairo| cairo._borrow_io(|cairo| (
    FFI_CALL_IO[() cairo_identity_matrix(Ptr), cairo]
));

user_to_device : (F64, F64) -> Cairo -> IO (F64, F64);
user_to_device = |(x, y), cairo| cairo._borrow_io(|cairo| (
    let x = Boxed { value : x };
    let y = Boxed { value : y };
    x.mutate_boxed_io(|x| y.mutate_boxed_io(|y| 
        FFI_CALL_IO[() cairo_user_to_device(Ptr, Ptr, Ptr), cairo, x, y]
    ));;
    pure $ (x.@value, y.@value)
));

user_to_device_distance : (F64, F64) -> Cairo -> IO (F64, F64);
user_to_device_distance = |(dx, dy), cairo| cairo._borrow_io(|cairo| (
        let dx = Boxed { value : dx };
        let dy = Boxed { value : dy };
        dx.mutate_boxed_io(|dx| dy.mutate_boxed_io(|dy| 
            FFI_CALL_IO[() cairo_user_to_device_distance(Ptr, Ptr, Ptr), cairo, dx, dy]
        ));;
        pure $ (dx.@value, dy.@value)
    )
);

device_to_user : (F64, F64) -> Cairo -> IO (F64, F64);
device_to_user = |(x, y), cairo| cairo._borrow_io(|cairo| (
        let x = Boxed { value : x };
        let y = Boxed { value : y };
        x.mutate_boxed_io(|x| y.mutate_boxed_io(|y| 
            FFI_CALL_IO[() cairo_device_to_user(Ptr, Ptr, Ptr), cairo, x, y]
        ));;
        pure $ (x.@value, y.@value)
    )
);

device_to_user_distance : (F64, F64) -> Cairo -> IO (F64, F64);
device_to_user_distance = |(dx, dy), cairo| cairo._borrow_io(|cairo| (
        let dx = Boxed { value : dx };
        let dy = Boxed { value : dy };
        dx.mutate_boxed_io(|dx| dy.mutate_boxed_io(|dy| 
            FFI_CALL_IO[() cairo_device_to_user_distance(Ptr, Ptr, Ptr), cairo, dx, dy]
        ));;
        pure $ (dx.@value, dy.@value)
    )
);

select_font_face : String -> FontSlant -> FontWeight -> Cairo -> IO ();
select_font_face = |font, slant, weight, cairo| cairo._borrow_io(|cairo| (
        font.borrow_c_str(|font| (
            FFI_CALL_IO[() cairo_select_font_face(Ptr, Ptr, I32, I32), cairo, font, slant, weight]
        ))
    )
);

set_font_size : F64 -> Cairo -> IO ();
set_font_size = |size, cairo| cairo._borrow_io(|cairo| (
        FFI_CALL_IO[() cairo_set_font_size(Ptr, F64), cairo, size]
    )
);

set_font_matrix : Matrix -> Cairo -> IO ();
set_font_matrix = |matrix, cairo| cairo._borrow_io(|cairo| (
        matrix._with_ptr_io(|matrix| (
            FFI_CALL_IO[() cairo_set_font_matrix(Ptr, Ptr), cairo, matrix]
        ))
    )
);

get_font_matrix : Cairo -> IO Matrix;
get_font_matrix = |cairo| cairo._borrow_io(|cairo|
    let matrix = Matrix::init_identity;
    let (matrix, _) = *matrix._mutate_io(|matrix| (
        FFI_CALL_IO[() cairo_get_font_matrix(Ptr, Ptr), cairo, matrix]
    ));
    pure $ matrix
);

set_font_options : FontOptions -> Cairo -> IO ();
set_font_options = |options, cairo| cairo._borrow_io(|cairo| (
        options._borrow_io(|options| (
            FFI_CALL_IO[() cairo_set_font_options(Ptr, Ptr), cairo, options]
        ))
    )
);

get_font_options : Cairo -> IO FontOptions;
get_font_options = |cairo| (
    cairo._borrow_io(|cairo| (
        let (options, _) = FontOptions::default._mutate(|options| (
            FFI_CALL_IO[() cairo_get_font_options(Ptr, Ptr), cairo, options]
        ));
        pure $ options
    ))
);

set_font_face : FontFace -> Cairo -> IO ();
set_font_face = |face, cairo| cairo._borrow_io(|cairo| (
        face._borrow_io(|face| (
            FFI_CALL_IO[() cairo_set_font_face(Ptr, Ptr), cairo, face]
        ))
    )
);

get_font_face : Cairo -> IO FontFace;
get_font_face = |cairo| (
    let face = *cairo._borrow_io(|cairo| (
        FFI_CALL_IO[Ptr cairo_get_font_face(Ptr), cairo]
    ));
    let face = *FFI_CALL_IO[Ptr cairo_font_face_reference(Ptr), face];
    pure $ FontFace::_create_from_handle(face)
);

set_scaled_font : ScaledFont -> Cairo -> IO ();
set_scaled_font = |scaled_font, cairo| (
    cairo._borrow_io(|cairo| (
        scaled_font._borrow_io(|scaled_font| (
            FFI_CALL_IO[() cairo_set_scaled_font(Ptr, Ptr), cairo, scaled_font]
        ))
    ))
);

get_scaled_font : Cairo -> IO ScaledFont;
get_scaled_font = |cairo| (
    let scaled_font = *cairo._borrow_io(|cairo| (
        FFI_CALL_IO[Ptr cairo_get_scaled_font(Ptr), cairo]
    ));
    let scaled_font = *FFI_CALL_IO[Ptr cairo_scaled_font_reference(Ptr), scaled_font];
    pure $ ScaledFont::_create_from_handle(scaled_font)
);

show_text : String -> Cairo -> IO ();
show_text = |text, cairo| (
    cairo._borrow_io(|cairo| (
        text.borrow_c_str(|text| (
            FFI_CALL_IO[() cairo_show_text(Ptr, Ptr), cairo, text]
        ))
    ))
);

show_glyphs : Array Glyph -> Cairo -> IO ();
show_glyphs = |glyphs, cairo| (
    cairo._borrow_io(|cairo| (
        let num_glyphs = glyphs.get_size.to_I32;
        glyphs.borrow_ptr(|glyphs| (
            FFI_CALL_IO[() cairo_show_glyphs(Ptr, Ptr, I32), cairo, glyphs, num_glyphs]
        ))
    ))
);

show_text_glyphs : String -> Array Glyph -> Array TextCluster -> TextClusterFlags -> Cairo -> IO ();
show_text_glyphs = |text, glyphs, clusters, flags, cairo| (
    cairo._borrow_io(|cairo| (
        let text_len = text.get_size.to_I32;
        text.borrow_c_str(|text| (
            let num_glyphs = glyphs.get_size.to_I32;
            let num_clusters = clusters.get_size.to_I32;
            glyphs.borrow_ptr(|glyphs| (
                clusters.borrow_ptr(|clusters| (
                    FFI_CALL_IO[() cairo_show_text_glyphs(Ptr, Ptr, I32, Ptr, I32, Ptr, I32, U32), cairo, text, text_len, glyphs, num_glyphs, clusters, num_clusters, flags]
                ))
            ))
        ))
    ))
);

font_extents : Cairo -> IO FontExtents;
font_extents = |cairo| (
    cairo._borrow_io(|cairo| (
        let extents = FontExtents::create;
        let (extents, _) = *extents._mutate_io(|extents| (
            FFI_CALL_IO[() cairo_font_extents(Ptr, Ptr), cairo, extents]
        ));
        pure $ extents
    ))
);

text_extents : String -> Cairo -> IO TextExtents;
text_extents = |text, cairo| (
    cairo._borrow_io(|cairo| (
        let extents = TextExtents::create;
        let (extents, _) = *text.borrow_c_str_io(|text| (
            extents._mutate_io(|extents| (
                FFI_CALL_IO[() cairo_text_extents(Ptr, Ptr, Ptr), cairo, text, extents]
            ))
        ));
        pure $ extents
    ))
);

glyph_extents : Array Glyph -> Cairo -> IO TextExtents;
glyph_extents = |glyphs, cairo| (
    cairo._borrow_io(|cairo| (
        let extents = TextExtents::create;
        let num_glyphs = glyphs.get_size.to_I32;
        let (extents, _) = *glyphs.borrow_ptr(|glyphs| (
            extents._mutate_io(|extents| (
                FFI_CALL_IO[() cairo_glyph_extents(Ptr, Ptr, I32, Ptr), cairo, glyphs, num_glyphs, extents]
            ))
        ));
        pure $ extents
    ))
);

type Surface = unbox struct { _dtor : Destructor (SurfaceHandle) };

namespace Surface {

    type SurfaceHandle = Ptr;

    _borrow : (SurfaceHandle -> a) -> Surface -> a;
    _borrow = |act, surface| surface.@_dtor.borrow(act);

    _borrow_io : (SurfaceHandle -> IO a) -> Surface -> IO a;
    _borrow_io = |act, surface| surface.@_dtor.borrow_io(act);

    _create_from_handle : SurfaceHandle -> Surface;
    _create_from_handle = |handle| Surface { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_surface_destroy(Ptr), handle];; pure $ nullptr) };

    write_to_png : Std::Path -> Surface -> IO ();
    write_to_png = |path, surface| (
        surface._borrow_io(|surface| (
            path.to_string.borrow_c_str(|path| (
                FFI_CALL_IO[() cairo_surface_write_to_png(Ptr, Ptr), surface, path]
            )) 
        ))
    );
}

type Pattern = unbox struct { _dtor : Destructor PatternHandle };

namespace Pattern {

    type PatternHandle = Ptr;

    _borrow : (PatternHandle -> a) -> Pattern -> a;
    _borrow = |act, pattern| pattern.@_dtor.borrow(act);

    _borrow_io : (PatternHandle -> IO a) -> Pattern -> IO a;
    _borrow_io = |act, pattern| pattern.@_dtor.borrow_io(act);

    _create_from_handle : PatternHandle -> Pattern;
    _create_from_handle = |handle| Pattern { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_pattern_destroy(Ptr), handle];; pure $ nullptr) };

    add_color_stop_rgb : F64 -> (F64, F64, F64) -> Pattern -> IO ();
    add_color_stop_rgb = |offset, (r, g, b), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_pattern_add_color_stop_rgb(Ptr, F64, F64, F64, F64), pattern, offset, r, g, b]
        ))
    );

    add_color_stop_rgba : F64 -> (F64, F64, F64, F64) -> Pattern -> IO ();
    add_color_stop_rgba = |offset, (r, g, b, a), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_pattern_add_color_stop_rgba(Ptr, F64, F64, F64, F64, F64), pattern, offset, r, g, b, a]
        ))
    );

    get_color_stop_count : Pattern -> IO I64;
    get_color_stop_count = |pattern| pattern._borrow_io(|pattern| (
        let count = *FFI_CALL_IO[I32 cairo_pattern_get_color_stop_count(Ptr), pattern];
        pure $ count.to_I64
    ));

    get_color_stop_rgba : I32 -> Pattern -> IO (Result Status (F64, F64, F64, F64));
    get_color_stop_rgba = |index, pattern| pattern._borrow_io(|pattern| (
        let rgba = Array::fill(4, 0.0);
        let (rgba, status) = *rgba.mutate_boxed_io(|p|
            FFI_CALL_IO[
                I32 cairo_pattern_get_color_stop_rgba(Ptr, I32, Ptr, Ptr, Ptr, Ptr), 
                pattern, index, 
                p, p.add_offset(8), p.add_offset(8 * 2), p.add_offset(8 * 3)
            ]
        );
        if status == Status::success {
            pure $ Result::ok $ (rgba.@(0), rgba.@(1), rgba.@(2), rgba.@(3))
        } else {
            pure $ Result::err $ status
        }
    ));

    create_rgb : (F64, F64, F64) -> Pattern;
    create_rgb = |(r, g, b)| (
        let handle = FFI_CALL[Ptr cairo_pattern_create_rgb(F64, F64, F64), r, g, b];
        Pattern::_create_from_handle(handle)
    );

    create_rgba : (F64, F64, F64, F64) -> Pattern;
    create_rgba = |(r, g, b, a)| (
        let handle = FFI_CALL[Ptr cairo_pattern_create_rgba(F64, F64, F64, F64), r, g, b, a];
        Pattern::_create_from_handle(handle)
    );

    get_rgba : Pattern -> IO (Result Status (F64, F64, F64, F64));
    get_rgba = |pattern| pattern._borrow_io(|pattern| (
        let rgba = Array::fill(4, 0.0);
        let (rgba, status) = *rgba.mutate_boxed_io(|p| 
            FFI_CALL_IO[
                I32 cairo_pattern_get_rgba(Ptr, Ptr, Ptr, Ptr, Ptr), 
                pattern, 
                p, p.add_offset(8), p.add_offset(8 * 2), p.add_offset(8 * 3)
            ]
        );
        if status == Status::success {
            pure $ Result::ok $ (rgba.@(0), rgba.@(1), rgba.@(2), rgba.@(3))
        } else {
            pure $ Result::err $ status
        }
    ));

    create_for_surface : Surface -> IO Pattern;
    create_for_surface = |surface| (
        surface._borrow_io(|surface| (
            let handle = *FFI_CALL_IO[Ptr cairo_pattern_create_for_surface(Ptr), surface];
            pure $ Pattern::_create_from_handle(handle)
        ))
    );

    get_surface : Pattern -> IO (Result Status Surface);
    get_surface = |pattern| pattern._borrow_io(|pattern| (
        let surface = Boxed { value : nullptr };
        let (surface, status) = *surface.mutate_boxed_io(|surface| (
            FFI_CALL_IO[I32 cairo_pattern_get_surface(Ptr, Ptr), pattern, surface]
        ));
        if status == Status::success {
            let surface = surface.@value;
            let surface = FFI_CALL[Ptr cairo_surface_reference(Ptr), surface];
            pure $ Result::ok $ Surface::_create_from_handle(surface)
        } else {
            pure $ Result::err $ status
        }
    ));

    create_linear : (F64, F64) -> (F64, F64) -> Pattern;
    create_linear = |(x0, y0), (x1, y1)| (
        let handle = FFI_CALL[Ptr cairo_pattern_create_linear(F64, F64, F64, F64), x0, y0, x1, y1];
        Pattern::_create_from_handle(handle)
    );

    get_linear_points : Pattern -> IO (Result Status ((F64, F64), (F64, F64)));
    get_linear_points = |pattern| pattern._borrow_io(|pattern| (
        let coords = Array::fill(4, 0.0);
        let (coords, status) = *coords.mutate_boxed_io(|p|
            FFI_CALL_IO[
                I32 cairo_pattern_get_linear_points(Ptr, Ptr, Ptr, Ptr, Ptr), 
                pattern, 
                p, p.add_offset(8), p.add_offset(8 * 2), p.add_offset(8 * 3)
            ]
        );
        if status == Status::success {
            pure $ Result::ok $ ((coords.@(0), coords.@(1)), (coords.@(2), coords.@(3)))
        } else {
            pure $ Result::err $ status
        }
    ));

    create_radial : (F64, F64, F64) -> (F64, F64, F64) -> Pattern;
    create_radial = |(x0, y0, r0), (x1, y1, r1)| (
        let handle = FFI_CALL[Ptr cairo_pattern_create_radial(F64, F64, F64, F64, F64, F64), x0, y0, r0, x1, y1, r1];
        Pattern::_create_from_handle(handle)
    );

    get_radial_circles : Pattern -> IO (Result Status ((F64, F64, F64), (F64, F64, F64)));
    get_radial_circles = |pattern| pattern._borrow_io(|pattern| (
        let coords = Array::fill(6, 0.0);
        let (coords, status) = *coords.mutate_boxed_io(|p|
            FFI_CALL_IO[
                I32 cairo_pattern_get_radial_circles(Ptr, Ptr, Ptr, Ptr, Ptr, Ptr, Ptr), 
                pattern, 
                p, p.add_offset(8), p.add_offset(8 * 2), p.add_offset(8 * 3), p.add_offset(8 * 4), p.add_offset(8 * 5)
            ]
        );
        if status == Status::success {
            pure $ Result::ok $ ((coords.@(0), coords.@(1), coords.@(2)), (coords.@(3), coords.@(4), coords.@(5)))
        } else {
            pure $ Result::err $ status
        }
    ));

    create_mesh : Pattern;
    create_mesh = (
        let handle = FFI_CALL[Ptr cairo_pattern_create_mesh()];
        Pattern::_create_from_handle(handle)
    );

    mesh_begin_patch : Pattern -> IO ();
    mesh_begin_patch = |pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_begin_patch(Ptr), pattern]
        ))
    );

    mesh_end_patch : Pattern -> IO ();
    mesh_end_patch = |pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_end_patch(Ptr), pattern]
        ))
    );

    mesh_move_to : (F64, F64) -> Pattern -> IO ();
    mesh_move_to = |(x, y), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_move_to(Ptr, F64, F64), pattern, x, y]
        ))
    );

    mesh_line_to : (F64, F64) -> Pattern -> IO ();
    mesh_line_to = |(x, y), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_line_to(Ptr, F64, F64), pattern, x, y]
        ))
    );

    mesh_curve_to : (F64, F64) -> (F64, F64) -> (F64, F64) -> Pattern -> IO ();
    mesh_curve_to = |(x1, y1), (x2, y2), (x3, y3), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_curve_to(Ptr, F64, F64, F64, F64, F64, F64), pattern, x1, y1, x2, y2, x3, y3]
        ))
    );

    mesh_set_control_point : (F64, F64) -> Pattern -> IO ();
    mesh_set_control_point = |(x, y), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_set_control_point(Ptr, F64, F64), pattern, x, y]
        ))
    );

    mesh_set_corner_color_rgb : I64 -> (F64, F64, F64) -> Pattern -> IO ();
    mesh_set_corner_color_rgb = |corner, (r, g, b), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_set_corner_color_rgb(Ptr, U32, F64, F64, F64), pattern, corner.to_U32, r, g, b]
        ))
    );

    mesh_set_corner_color_rgba : I64 -> (F64, F64, F64, F64) -> Pattern -> IO ();
    mesh_set_corner_color_rgba = |corner, (r, g, b, a), pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_mesh_pattern_set_corner_color_rgba(Ptr, U32, F64, F64, F64, F64), pattern, corner.to_U32, r, g, b, a]
        ))
    );

    mesh_get_patch_count : Pattern -> IO (Result Status I64);
    mesh_get_patch_count = |pattern| pattern._borrow_io(|pattern| (
        let count = Boxed { value : 0_U32 };
        let (count, status) = *count.mutate_boxed_io(|count|FFI_CALL_IO[I32 cairo_mesh_pattern_get_patch_count(Ptr, Ptr), pattern, count]);
        if status == Status::success {
            pure $ Result::ok $ count.@value.to_I64
        } else {
            pure $ Result::err $ status
        }
    ));

    mesh_get_path : I64 -> Pattern -> IO Cairo::Path;
    mesh_get_path = |patch_num, pattern| pattern._borrow_io(|pattern| (
        let path = *FFI_CALL_IO[Ptr cairo_mesh_pattern_get_path(Ptr, U32), pattern, patch_num.to_U32];
        pure $ Path::_create_from_handle(path)
    ));

    mesh_get_control_point : I64 -> Pattern -> IO (Result Status (F64, F64));
    mesh_get_control_point = |corner, pattern| pattern._borrow_io(|pattern| (
        let xy = Array::fill(2, 0.0);
        let (xy, status) = *xy.mutate_boxed_io(|p| 
            FFI_CALL_IO[I32 cairo_mesh_pattern_get_control_point(Ptr, U32, Ptr, Ptr), pattern, corner.to_U32, p, p.add_offset(8)]
        );
        if status == Status::success {
            pure $ Result::ok $ (xy.@(0), xy.@(1))
        } else {
            pure $ Result::err $ status
        }
    ));

    mesh_get_corner_color_rgba : I64 -> Pattern -> IO (Result Status (F64, F64, F64, F64));
    mesh_get_corner_color_rgba = |corner, pattern| pattern._borrow_io(|pattern| (
        let rgba = Array::fill(4, 0.0);
        let (rgba, status) = *rgba.mutate_boxed_io(|p| 
            FFI_CALL_IO[
                I32 cairo_mesh_pattern_get_corner_color_rgba(Ptr, U32, Ptr, Ptr, Ptr, Ptr, Ptr),
                pattern, corner.to_U32,
                p, p.add_offset(8), p.add_offset(8 * 2), p.add_offset(8 * 3), p.add_offset(8 * 4)
            ]
        );
        if status == Status::success {
            pure $ Result::ok $ (rgba.@(0), rgba.@(1), rgba.@(2), rgba.@(3))
        } else {
            pure $ Result::err $ status
        }
    ));

    status : Pattern -> IO Status;
    status = |pattern| pattern._borrow_io(|pattern| (
        FFI_CALL_IO[I32 cairo_pattern_status(Ptr), pattern]
    ));

    set_extend : Extend -> Pattern -> IO ();
    set_extend = |extend, pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_pattern_set_extend(Ptr, I32), pattern, extend]
        ))
    );

    get_extend : Pattern -> IO Extend;
    get_extend = |pattern| pattern._borrow_io(|pattern| (
        FFI_CALL_IO[I32 cairo_pattern_get_extend(Ptr), pattern]
    ));

    set_filter : Filter -> Pattern -> IO ();
    set_filter = |filter, pattern| (
        pattern._borrow_io(|pattern| (
            FFI_CALL_IO[() cairo_pattern_set_filter(Ptr, I32), pattern, filter]
        ))
    );

    get_filter : Pattern -> IO Filter;
    get_filter = |pattern| pattern._borrow_io(|pattern| (
        FFI_CALL_IO[I32 cairo_pattern_get_filter(Ptr), pattern]
    ));

    set_matrix : Matrix -> Pattern -> IO ();
    set_matrix = |matrix, pattern| (
        pattern._borrow_io(|pattern| (
            matrix._with_ptr_io(|matrix| (
                FFI_CALL_IO[() cairo_pattern_set_matrix(Ptr, Ptr), pattern, matrix]
            ))
        ))
    );

    get_matrix : Pattern -> IO Matrix;
    get_matrix = |pattern| pattern._borrow_io(|pattern| (
        let matrix = Matrix::init_identity;
        let (matrix, _) = *matrix._mutate_io(|matrix| (
            FFI_CALL_IO[() cairo_pattern_get_matrix(Ptr, Ptr), pattern, matrix]
        ));
        pure $ matrix
    ));

    get_type : Pattern -> IO PatternType;
    get_type = |pattern| pattern._borrow_io(|pattern| (
        let pattern_type = FFI_CALL_IO[I32 cairo_pattern_get_type(Ptr), pattern];
        pattern_type
    ));
}

type RectangleList = unbox struct { _dtor : Destructor RectangleListHandle };

namespace RectangleList {

    type RectangleListHandle = Ptr;

    _borrow : (RectangleListHandle -> a) -> RectangleList -> a;
    _borrow = |act, list| list.@_dtor.borrow(act);

    _create_from_handle : RectangleListHandle -> RectangleList;
    _create_from_handle = |handle| RectangleList { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_rectangle_list_destroy(Ptr), handle];; pure $ nullptr) };

    // TODO: add a function RectangleList -> Iterator Rectangle, where Rectangle is a struct with x, y, width, height fields.
    // TODO: add a function RectangleList -> I64 that returns the number of rectangles in the list.
}

type Path = unbox struct { _dtor : Destructor PathHandle };

namespace Path {

    type PathHandle = Ptr;

    _borrow : (PathHandle -> a) -> Cairo::Path -> a;
    _borrow = |act, path| path.@_dtor.borrow(act);

    _borrow_io : (PathHandle -> IO a) -> Cairo::Path -> IO a;
    _borrow_io = |act, path| path.@_dtor.borrow_io(act);

    _create_from_handle : PathHandle -> Cairo::Path;
    _create_from_handle = |handle| Cairo::Path { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_path_destroy(Ptr), handle];; pure $ nullptr) };

    // TODO: add a function Path -> Iterator PathData, where PathData is Fix's equivalent of cairo_path_data_t.
    // TODO: add a function Path -> I64 that returns the number of elements in the path.
}

type Glyph = unbox struct { index : U64, x : F64, y : F64 };

type Matrix = unbox struct { xx : F64, yx : F64, xy : F64, yy : F64, x0 : F64, y0 : F64 };

namespace Matrix {

    _with_ptr_io : (Ptr -> IO a) -> Matrix -> IO a;
    _with_ptr_io = |act, matrix| (
        let mat = Boxed { value : matrix };
        mat.borrow_boxed_io(act)
    );

    _mutate : (Ptr -> IO a) -> Matrix -> (Matrix, a);
    _mutate = |act, matrix| (
        let mat = Boxed { value : matrix };
        let (mat, res) = mat.mutate_boxed(act);
        (mat.@value, res)
    );

    _mutate_io : (Ptr -> IO a) -> Matrix -> IO (Matrix, a);
    _mutate_io = |act, matrix| (
        let mat = Boxed { value : matrix };
        let (mat, res) = *mat.mutate_boxed_io(act);
        pure $ (mat.@value, res)
    );

    init_identity : Matrix;
    init_identity = Matrix { xx : 1.0, yx : 0.0, xy : 0.0, yy : 1.0, x0 : 0.0, y0 : 0.0 };

    init_translate : (F64, F64) -> Matrix;
    init_translate = |(x, y)| Matrix { xx : 1.0, yx : 0.0, xy : 0.0, yy : 1.0, x0 : x, y0 : y };

    init_scale : (F64, F64) -> Matrix;
    init_scale = |(x, y)| Matrix { xx : x, yx : 0.0, xy : 0.0, yy : y, x0 : 0.0, y0 : 0.0 };

    init_rotate : F64 -> Matrix;
    init_rotate = |angle| (
        let c = angle.cos;
        let s = angle.sin;
        Matrix { xx : c, yx : s, xy : -s, yy : c, x0 : 0.0, y0 : 0.0 }
    );

    translate : (F64, F64) -> Matrix -> Matrix;
    translate = |(x, y), matrix| matrix.set_x0(matrix.@x0 + x).set_y0(matrix.@y0 + y);

    scale : (F64, F64) -> Matrix -> Matrix;
    scale = |(x, y), matrix| matrix.set_xx(matrix.@xx * x).set_yx(matrix.@yx * x).set_xy(matrix.@xy * y).set_yy(matrix.@yy * y);

    rotate : F64 -> Matrix -> Matrix;
    rotate = |angle, matrix| (
        let c = angle.cos;
        let s = angle.sin;
        let xx = matrix.@xx * c + matrix.@yx * s;
        let yx = matrix.@xx * -s + matrix.@yx * c;
        let xy = matrix.@xy * c + matrix.@yy * s;
        let yy = matrix.@xy * -s + matrix.@yy * c;
        Matrix { xx : xx, yx : yx, xy : xy, yy : yy, x0 : matrix.@x0, y0 : matrix.@y0 }
    );

    invert : Matrix -> Option Matrix;
    invert = |matrix| (
        let det = matrix.@xx * matrix.@yy - matrix.@yx * matrix.@xy;
        if det == 0.0 {
            Option::none()
        } else {
            let inv_det = 1.0 / det;
            let xx = matrix.@yy * inv_det;
            let yx = -matrix.@yx * inv_det;
            let xy = -matrix.@xy * inv_det;
            let yy = matrix.@xx * inv_det;
            let x0 = (matrix.@xy * matrix.@y0 - matrix.@yy * matrix.@x0) * inv_det;
            let y0 = (matrix.@yx * matrix.@x0 - matrix.@xx * matrix.@y0) * inv_det;
            Option::some $ Matrix { xx : xx, yx : yx, xy : xy, yy : yy, x0 : x0, y0 : y0 }
        }
    );

    // The transformation b.multiply(a) first applies the transformation a to the point and then applies the transformation b to the result.
    multiply : Matrix -> Matrix -> Matrix;
    multiply = |a, b| (
        let xx = a.@xx * b.@xx + a.@yx * b.@xy;
        let yx = a.@xx * b.@yx + a.@yx * b.@yy;
        let xy = a.@xy * b.@xx + a.@yy * b.@xy;
        let yy = a.@xy * b.@yx + a.@yy * b.@yy;
        let x0 = a.@x0 * b.@xx + a.@y0 * b.@xy + b.@x0;
        let y0 = a.@x0 * b.@yx + a.@y0 * b.@yy + b.@y0;
        Matrix { xx : xx, yx : yx, xy : xy, yy : yy, x0 : x0, y0 : y0 }
    );

    transform_distance : (F64, F64) -> Matrix -> (F64, F64);
    transform_distance = |(dx, dy), matrix| (
        let dx = matrix.@xx * dx + matrix.@xy * dy;
        let dy = matrix.@yx * dx + matrix.@yy * dy;
        (dx, dy)
    );

    transform_point : (F64, F64) -> Matrix -> (F64, F64);
    transform_point = |(x, y), matrix| (
        let x = matrix.@xx * x + matrix.@xy * y + matrix.@x0;
        let y = matrix.@yx * x + matrix.@yy * y + matrix.@y0;
        (x, y)
    );
}

type Region = unbox struct { _dtor : Destructor RegionHandle };

namespace Region {

    type RegionHandle = Ptr;

    _borrow : (RegionHandle -> a) -> Region -> a;
    _borrow = |act, region| region.@_dtor.borrow(act);

    _borrow_io : (RegionHandle -> IO a) -> Region -> IO a;
    _borrow_io = |act, region| region.@_dtor.borrow_io(act);

    _create_from_handle : RegionHandle -> Region;
    _create_from_handle = |handle| Region { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_region_destroy(Ptr), handle];; pure $ nullptr) };

    _mutate : (RegionHandle -> IO a) -> Region -> (Region, a);
    _mutate = |act, region| (
        let dtor = region.@_dtor;
        let (dtor, res) = dtor.mutate_unique(|region| FFI_CALL_IO[Ptr cairo_region_copy(Ptr), region], act);
        (Region { _dtor : dtor }, res)
    );

    create : Region;
    create = (
        let handle = FFI_CALL[Ptr cairo_region_create()];
        Region::_create_from_handle(handle)
    );

    create_rectangle : RectangleInt -> Region;
    create_rectangle = |rect| (
        let rect = rect._with_ptr(|rect| (
            FFI_CALL[Ptr cairo_region_create_rectangle(Ptr), rect]
        ));
        Region::_create_from_handle(rect)
    );

    create_rectangles : Array RectangleInt -> Region;
    create_rectangles = |rects| (
        let len = rects.get_size;
        let region = rects.borrow_ptr(|handles| FFI_CALL[Ptr cairo_region_create_rectangles(Ptr, I32), handles, len.to_I32]);
        Region::_create_from_handle(region)
    );

    status : Region -> Status;
    status = |region| region._borrow(|region| (
        FFI_CALL[I32 cairo_region_status(Ptr), region]
    ));

    get_extents : Region -> RectangleInt;
    get_extents = |region| region._borrow(|region| (
        let rect = Boxed { value : RectangleInt { x : 0_I32, y : 0_I32, width : 0_I32, height : 0_I32 } };
        let (rect, _) = rect.mutate_boxed(|rect| (
            FFI_CALL_IO[() cairo_region_get_extents(Ptr, Ptr), region, rect]
        ));
        rect.@value
    ));

    num_rectangles : Region -> I32;
    num_rectangles = |region| region._borrow(|region| (
        FFI_CALL[I32 cairo_region_num_rectangles(Ptr), region]
    ));

    get_rectangle : I32 -> Region -> RectangleInt;
    get_rectangle = |index, region| region._borrow(|region| (
        let rect = Boxed { value : RectangleInt { x : 0_I32, y : 0_I32, width : 0_I32, height : 0_I32 } };
        let (rect, _) = rect.mutate_boxed(|rect| (
            FFI_CALL_IO[() cairo_region_get_rectangle(Ptr, I32, Ptr), region, index, rect]
        ));
        rect.@value
    ));

    is_empty : Region -> Bool;
    is_empty = |region| region._borrow(|region| (
        let is_empty = FFI_CALL[I32 cairo_region_is_empty(Ptr), region];
        is_empty != 0_I32
    ));

    contains_point : (I32, I32) -> Region -> Bool;
    contains_point = |(x, y), region| region._borrow(|region| (
        let contains_point = FFI_CALL[I32 cairo_region_contains_point(Ptr, I32, I32), region, x, y];
        contains_point != 0_I32
    ));

    contains_rectangle : RectangleInt -> Region -> Overlap;
    contains_rectangle = |rect, region| (
        rect._with_ptr(|rect| region._borrow(|region|
            FFI_CALL[I32 cairo_region_contains_rectangle(Ptr, Ptr), region, rect]
        ))
    );

    equal : Region -> Region -> Bool;
    equal = |region1, region2| (
        region1._borrow(|region1| (
            region2._borrow(|region2| (
                let equal = FFI_CALL[I32 cairo_region_equal(Ptr, Ptr), region1, region2];
                equal != 0_I32
            ))
        ))
    );

    translate : (I32, I32) -> Region -> Region;
    translate = |(dx, dy), region| (
        let (region, _) = region._mutate(|region| (
            FFI_CALL_IO[() cairo_region_translate(Ptr, I32, I32), region, dx, dy]
        ));
        region
    );

    intersect : Region -> Region -> Result Status Region;
    intersect = |region1, region2| (
        let (region, status) = region2._borrow(|region2|
            region1._mutate(|region1|
                FFI_CALL_IO[I32 cairo_region_intersect(Ptr, Ptr), region1, region2]
            )
        );
        if status == Status::success {
            Result::ok $ region1
        } else {
            Result::err $ status
        }
    );

    intersect_rectangle : RectangleInt -> Region -> Result Status Region;
    intersect_rectangle = |rect, region| (
        let (region, status) = rect._with_ptr(|rect| 
            region._mutate(|region|
                FFI_CALL_IO[I32 cairo_region_intersect_rectangle(Ptr, Ptr), region, rect]
            )
        );
        if status == Status::success {
            Result::ok $ region
        } else {
            Result::err $ status
        }
    );

    subtract : Region -> Region -> Result Status Region;
    subtract = |other, dst| (
        let (dst, status) = other._borrow(|other| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_subtract(Ptr, Ptr), dst, other]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );

    subtract_rectangle : RectangleInt -> Region -> Result Status Region;
    subtract_rectangle = |rect, dst| (
        let (dst, status) = rect._with_ptr(|rect| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_subtract_rectangle(Ptr, Ptr), dst, rect]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );

    union_ : Region -> Region -> Result Status Region;
    union_ = |other, dst| (
        let (dst, status) = other._borrow(|other| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_union(Ptr, Ptr), dst, other]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );

    union_rectangle : RectangleInt -> Region -> Result Status Region;
    union_rectangle = |rect, dst| (
        let (dst, status) = rect._with_ptr(|rect| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_union_rectangle(Ptr, Ptr), dst, rect]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );

    xor : Region -> Region -> Result Status Region;
    xor = |other, dst| (
        let (dst, status) = other._borrow(|other| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_xor(Ptr, Ptr), dst, other]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );

    xor_rectangle : RectangleInt -> Region -> Result Status Region;
    xor_rectangle = |rect, dst| (
        let (dst, status) = rect._with_ptr(|rect| (
            dst._mutate(|dst| (
                FFI_CALL_IO[I32 cairo_region_xor_rectangle(Ptr, Ptr), dst, rect]
            ))
        ));
        if status == Status::success {
            Result::ok $ dst
        } else {
            Result::err $ status
        }
    );
}

type RectangleInt = unbox struct { x : I32, y : I32, width : I32, height : I32 };

namespace RectangleInt {

    _with_ptr : (Ptr -> a) -> RectangleInt -> a;
    _with_ptr = |act, rect| (
        let rect = Boxed { value : rect };
        rect.borrow_boxed(act)
    );

    _mutate_io : (Ptr -> IO a) -> RectangleInt -> IO (RectangleInt, a);
    _mutate_io = |act, rect| (
        let rect = Boxed { value : rect };
        let (rect, res) = *rect.mutate_boxed_io(act);
        pure $ (rect.@value, res)
    );
}

type FontOptions = unbox struct { _dtor : Destructor FontOptionsHandle };

namespace FontOptions {

    type FontOptionsHandle = Ptr;

    _borrow : (FontOptionsHandle -> a) -> FontOptions -> a;
    _borrow = |act, options| options.@_dtor.borrow(act);

    _borrow_io : (FontOptionsHandle -> IO a) -> FontOptions -> IO a;
    _borrow_io = |act, options| options.@_dtor.borrow_io(act);

    _mutate : (FontOptionsHandle -> IO a) -> FontOptions -> (FontOptions, a);
    _mutate = |act, fo| (
        let dtor = fo.@_dtor;
        let (dtor, res) = dtor.mutate_unique(|fo| FFI_CALL_IO[Ptr cairo_font_options_copy(Ptr), fo], act);
        (FontOptions { _dtor : dtor }, res)
    );

    _create_from_handle : FontOptionsHandle -> FontOptions;
    _create_from_handle = |handle| FontOptions { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_font_options_destroy(Ptr), handle];; pure $ nullptr) };

    default : FontOptions;
    default = (
        let handle = FFI_CALL[Ptr cairo_font_options_create()];
        FontOptions::_create_from_handle(handle)
    );

    status : FontOptions -> Status;
    status = |options| options._borrow(|options| (
        FFI_CALL[I32 cairo_font_options_status(Ptr), options]
    ));

    merge : FontOptions -> FontOptions -> FontOptions;
    merge = |other, options| (
        let (options, _) = other._borrow(|other| (
            options._mutate(|options| (
                FFI_CALL_IO[() cairo_font_options_merge(Ptr, Ptr), options, other]
            ))
        ));
        options
    );

    hash : FontOptions -> U64;
    hash = |options| options._borrow(|options| (
        FFI_CALL[U64 cairo_font_options_hash(Ptr), options]
    ));

    equal : FontOptions -> FontOptions -> Bool;
    equal = |options1, options2| (
        options1._borrow(|options1| (
            options2._borrow(|options2| (
                let equal = FFI_CALL[I32 cairo_font_options_equal(Ptr, Ptr), options1, options2];
                equal != 0_I32
            ))
        ))
    );

    set_antialias : Antialias -> FontOptions -> FontOptions;
    set_antialias = |antialias, options| (
        let (options, _) = options._mutate(|options| (
            FFI_CALL_IO[() cairo_font_options_set_antialias(Ptr, I32), options, antialias]
        ));
        options
    );

    get_antialias : FontOptions -> Antialias;
    get_antialias = |options| options._borrow(|options| (
        FFI_CALL[I32 cairo_font_options_get_antialias(Ptr), options]
    ));

    set_subpixel_order : SubpixelOrder -> FontOptions -> FontOptions;
    set_subpixel_order = |order, options| (
        let (options, _) = options._mutate(|options| (
            FFI_CALL_IO[() cairo_font_options_set_subpixel_order(Ptr, I32), options, order]
        ));
        options
    );

    get_subpixel_order : FontOptions -> SubpixelOrder;
    get_subpixel_order = |options| options._borrow(|options| (
        FFI_CALL[I32 cairo_font_options_get_subpixel_order(Ptr), options]
    ));

    set_hint_style : HintStyle -> FontOptions -> FontOptions;
    set_hint_style = |style, options| (
        let (option, _) = options._mutate(|options| (
            FFI_CALL_IO[() cairo_font_options_set_hint_style(Ptr, I32), options, style]
        ));
        options
    );

    get_hint_style : FontOptions -> HintStyle;
    get_hint_style = |options| options._borrow(|options| (
        FFI_CALL[I32 cairo_font_options_get_hint_style(Ptr), options]
    ));

    set_hint_metrics : HintMetrics -> FontOptions -> FontOptions;
    set_hint_metrics = |metrics, options| (
        let (options, _) = options._mutate(|options| (
            FFI_CALL_IO[() cairo_font_options_set_hint_metrics(Ptr, I32), options, metrics]
        ));
        options
    );

    get_hint_metrics : FontOptions -> HintMetrics;
    get_hint_metrics = |options| options._borrow(|options| (
        FFI_CALL[I32 cairo_font_options_get_hint_metrics(Ptr), options]
    ));

    get_variations : FontOptions -> String;
    get_variations = |options| options._borrow(|options| (
        let variations = FFI_CALL[Ptr cairo_font_options_get_variations(Ptr), options];
        String::_unsafe_from_c_str_ptr(variations)
    ));

    set_variations : String -> FontOptions -> FontOptions;
    set_variations = |variations, options| (
        let (options, _) = variations.borrow_c_str(|variations| 
            options._mutate(|options| 
                FFI_CALL_IO[() cairo_font_options_set_variations(Ptr, Ptr), options, variations]
            )
        );
        options
    );
}

type FontFace = unbox struct { _dtor : Destructor FontFaceHandle };

namespace FontFace {

    type FontFaceHandle = Ptr;

    _borrow : (FontFaceHandle -> a) -> FontFace -> a;
    _borrow = |act, face| face.@_dtor.borrow(act);

    _borrow_io : (FontFaceHandle -> IO a) -> FontFace -> IO a;
    _borrow_io = |act, face| face.@_dtor.borrow_io(act);

    _create_from_handle : FontFaceHandle -> FontFace;
    _create_from_handle = |handle| FontFace { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_font_face_destroy(Ptr), handle];; pure $ nullptr) };

    status : FontFace -> Status;
    status = |face| face._borrow(|face| (
        FFI_CALL[I32 cairo_font_face_status(Ptr), face]
    ));

    get_type : FontFace -> FontType;
    get_type = |face| face._borrow(|face| (
        FFI_CALL[I32 cairo_font_face_get_type(Ptr), face]
    ));
}

namespace ToyFontFace {

    create : String -> FontSlant -> FontWeight -> FontFace;
    create = |family, slant, weight| (
        family.borrow_c_str(|family| (
            let handle = FFI_CALL[Ptr cairo_toy_font_face_create(Ptr, I32, I32), family, slant, weight];
            FontFace::_create_from_handle(handle)
        ))
    );

    get_family : FontFace -> String;
    get_family = |face| face._borrow(|face| (
        let family = FFI_CALL[Ptr cairo_toy_font_face_get_family(Ptr), face];
        String::_unsafe_from_c_str_ptr(family)
    ));

    get_slant : FontFace -> FontSlant;
    get_slant = |face| face._borrow(|face| (
        FFI_CALL[I32 cairo_toy_font_face_get_slant(Ptr), face]
    ));

    get_weight : FontFace -> FontWeight;
    get_weight = |face| face._borrow(|face| (
        FFI_CALL[I32 cairo_toy_font_face_get_weight(Ptr), face]
    ));
}

type ScaledFont = unbox struct { _dtor : Destructor ScaledFontHandle };

namespace ScaledFont {

    type ScaledFontHandle = Ptr;

    _borrow : (ScaledFontHandle -> a) -> ScaledFont -> a;
    _borrow = |act, font| font.@_dtor.borrow(act);

    _borrow_io : (ScaledFontHandle -> IO a) -> ScaledFont -> IO a;
    _borrow_io = |act, font| font.@_dtor.borrow_io(act);

    _create_from_handle : ScaledFontHandle -> ScaledFont;
    _create_from_handle = |handle| ScaledFont { _dtor : Destructor::make(handle, |handle| FFI_CALL_IO[() cairo_scaled_font_destroy(Ptr), handle];; pure $ nullptr) };

    status : ScaledFont -> Status;
    status = |font| font._borrow(|font| (
        FFI_CALL[I32 cairo_scaled_font_status(Ptr), font]
    ));

    extents : ScaledFont -> FontExtents;
    extents = |font| font._borrow(|font| (
        let extents = FontExtents { ascent : 0.0, descent : 0.0, height : 0.0, max_x_advance : 0.0, max_y_advance : 0.0 };
        let (extents, _) = extents._mutate(|extents| (
            FFI_CALL_IO[() cairo_scaled_font_extents(Ptr, Ptr), font, extents]
        ));
        extents
    ));

    text_extents : String -> ScaledFont -> TextExtents;
    text_extents = |text, font| font._borrow(|font| (
        let extents = TextExtents { x_bearing : 0.0, y_bearing : 0.0, width : 0.0, height : 0.0, x_advance : 0.0, y_advance : 0.0 };
        let (extents, _) = text.borrow_c_str(|text| 
            extents._mutate(|extents| 
                FFI_CALL_IO[() cairo_scaled_font_text_extents(Ptr, Ptr, Ptr), font, text, extents]
            )
        );
        extents
    ));

    glyph_extents : Array Glyph -> ScaledFont -> TextExtents;
    glyph_extents = |glyphs, font| (
        let len = glyphs.get_size;
        let extents = TextExtents { x_bearing : 0.0, y_bearing : 0.0, width : 0.0, height : 0.0, x_advance : 0.0, y_advance : 0.0 };
        let (extents, _) = glyphs.borrow_ptr(|glyphs| (font._borrow(|font| extents._mutate(|extents| (
                FFI_CALL_IO[() cairo_scaled_font_glyph_extents(Ptr, Ptr, I32, Ptr), font, glyphs, len.to_I32, extents]
            ))
        )));
        extents
    );

    // text_to_glyphs : (F64, F64) -> String -> ScaledFont -> Result Status (Array Glyph, Array TextCluster, TextClusterFlags);
    // It is hard to wrap cairo_scaled_font_text_to_glyphs in current state of FFI of Fix.

    get_font_face : ScaledFont -> FontFace;
    get_font_face = |font| font._borrow(|font| (
        let face = FFI_CALL[Ptr cairo_scaled_font_get_font_face(Ptr), font];
        let face = FFI_CALL[Ptr cairo_font_face_reference(Ptr), face];
        FontFace::_create_from_handle(face)
    ));

    get_font_options : ScaledFont -> FontOptions;
    get_font_options = |font| font._borrow(|font| (
        let options = FontOptions::default;
        let (options, _) = options._mutate(|options| (
            FFI_CALL_IO[() cairo_scaled_font_get_font_options(Ptr, Ptr), font, options]
        ));
        options
    ));

    get_font_matrix : ScaledFont -> Matrix;
    get_font_matrix = |font| font._borrow(|font| (
        let (matrix, _) = Matrix::init_identity._mutate(|matrix| 
            FFI_CALL_IO[() cairo_scaled_font_get_font_matrix(Ptr, Ptr), font, matrix]
        );
        matrix
    ));

    get_ctm : ScaledFont -> Matrix;
    get_ctm = |font| font._borrow(|font| (
        let (matrix, _) = Matrix::init_identity._mutate(|matrix| 
            FFI_CALL_IO[() cairo_scaled_font_get_ctm(Ptr, Ptr), font, matrix]
        );
        matrix
    ));

    get_scale_matrix : ScaledFont -> Matrix;
    get_scale_matrix = |font| font._borrow(|font| (
        let (matrix, _) = Matrix::init_identity._mutate(|matrix| 
            FFI_CALL_IO[() cairo_scaled_font_get_scale_matrix(Ptr, Ptr), font, matrix]
        );
        matrix
    ));

    get_type : ScaledFont -> FontType;
    get_type = |font| font._borrow(|font| (
        FFI_CALL[I32 cairo_scaled_font_get_type(Ptr), font]
    ));
}

type FontExtents = unbox struct { ascent : F64, descent : F64, height : F64, max_x_advance : F64, max_y_advance : F64 };

namespace FontExtents {

    create : FontExtents;
    create = FontExtents { ascent : 0.0, descent : 0.0, height : 0.0, max_x_advance : 0.0, max_y_advance : 0.0 };

    _mutate : (Ptr -> IO a) -> FontExtents -> (FontExtents, a);
    _mutate = |act, extents| (
        let extents = Boxed { value : extents };
        let (extents, res) = extents.mutate_boxed(act);
        (extents.@value, res)
    );

    _mutate_io : (Ptr -> IO a) -> FontExtents -> IO (FontExtents, a);
    _mutate_io = |act, extents| (
        let extents = Boxed { value : extents };
        let (extents, res) = *extents.mutate_boxed_io(act);
        pure $ (extents.@value, res)
    );
}

type TextExtents = unbox struct { x_bearing : F64, y_bearing : F64, width : F64, height : F64, x_advance : F64, y_advance : F64 };

namespace TextExtents {

    create : TextExtents;
    create = TextExtents { x_bearing : 0.0, y_bearing : 0.0, width : 0.0, height : 0.0, x_advance : 0.0, y_advance : 0.0 };

    _mutate : (Ptr -> IO a) -> TextExtents -> (TextExtents, a);
    _mutate = |act, extents| (
        let extents = Boxed { value : extents };
        let (extents, res) = extents.mutate_boxed(act);
        (extents.@value, res)
    );

    _mutate_io : (Ptr -> IO a) -> TextExtents -> IO (TextExtents, a);
    _mutate_io = |act, extents| (
        let extents = Boxed { value : extents };
        let (extents, res) = *extents.mutate_boxed_io(act);
        pure $ (extents.@value, res)
    );
}

type TextCluster = unbox struct { num_bytes : I32, num_glyphs : I32 };

namespace TextCluster {

    _with_ptr : (Ptr -> a) -> TextCluster -> (a, TextCluster);
    _with_ptr = |act, cluster| (
        let arr = [cluster];
        let res = arr.borrow_ptr(act);
        (res, arr.@(0))
    );
}

type Status = I32;

namespace Status {

    success : Status;
    success = 0_I32;

    no_memory : Status;
    no_memory = 1_I32;

    invalid_restore : Status;
    invalid_restore = 2_I32;

    invalid_pop_group : Status;
    invalid_pop_group = 3_I32;

    no_current_point : Status;
    no_current_point = 4_I32;

    invalid_matrix : Status;
    invalid_matrix = 5_I32;

    invalid_status : Status;
    invalid_status = 6_I32;

    null_pointer : Status;
    null_pointer = 7_I32;

    invalid_string : Status;
    invalid_string = 8_I32;

    invalid_path_data : Status;
    invalid_path_data = 9_I32;

    read_error : Status;
    read_error = 10_I32;

    write_error : Status;
    write_error = 11_I32;

    surface_finished : Status;
    surface_finished = 12_I32;

    surface_type_mismatch : Status;
    surface_type_mismatch = 13_I32;

    pattern_type_mismatch : Status;
    pattern_type_mismatch = 14_I32;

    invalid_content : Status;
    invalid_content = 15_I32;

    invalid_format : Status;
    invalid_format = 16_I32;

    invalid_visual : Status;
    invalid_visual = 17_I32;

    file_not_found : Status;
    file_not_found = 18_I32;

    invalid_dash : Status;
    invalid_dash = 19_I32;

    invalid_dsc_comment : Status;
    invalid_dsc_comment = 20_I32;

    invalid_index : Status;
    invalid_index = 21_I32;

    clip_not_representable : Status;
    clip_not_representable = 22_I32;

    temp_file_error : Status;
    temp_file_error = 23_I32;

    invalid_stride : Status;
    invalid_stride = 24_I32;

    font_type_mismatch : Status;
    font_type_mismatch = 25_I32;

    user_font_immutable : Status;
    user_font_immutable = 26_I32;

    user_font_error : Status;
    user_font_error = 27_I32;

    negative_count : Status;
    negative_count = 28_I32;

    invalid_clusters : Status;
    invalid_clusters = 29_I32;

    invalid_slant : Status;
    invalid_slant = 30_I32;

    invalid_weight : Status;
    invalid_weight = 31_I32;

    invalid_size : Status;
    invalid_size = 32_I32;

    user_font_not_implemented : Status;
    user_font_not_implemented = 33_I32;

    device_type_mismatch : Status;
    device_type_mismatch = 34_I32;

    device_error : Status;
    device_error = 35_I32;
}

type Content = I32;

namespace Content {

    color : Content;
    color = 0x1000_I32;

    alpha : Content;
    alpha = 0x2000_I32;

    color_alpha : Content;
    color_alpha = 0x3000_I32;
}

type Format = I32;

namespace Format {

    argb : Format;
    argb = 0_I32;

    rgb24 : Format;
    rgb24 = 1_I32;

    a8 : Format;
    a8 = 2_I32;

    a1 : Format;
    a1 = 3_I32;

    rgb16_565 : Format;
    rgb16_565 = 4_I32;

    rgb30 : I32;
    rgb30 = 5_I32;
}

type FontSlant = I32;

namespace FontSlant {

    normal : FontSlant;
    normal = 0_I32;

    italic : FontSlant;
    italic = 1_I32;

    oblique : FontSlant;
    oblique = 2_I32;
}

type FontWeight = I32;

namespace FontWeight {

    normal : FontWeight;
    normal = 0_I32;

    bold : FontWeight;
    bold = 1_I32;
}

type Antialias = I32;

namespace Antialias {

    default : Antialias;
    default = 0_I32;

    none : Antialias;
    none = 1_I32;

    gray : Antialias;
    gray = 2_I32;

    subpixel : Antialias;
    subpixel = 3_I32;

    fast : Antialias;
    fast = 4_I32;

    good : Antialias;
    good = 5_I32;

    best : Antialias;
    best = 6_I32;
}

type FillRule = I32;

namespace FillRule {

    winding : FillRule;
    winding = 0_I32;

    even_odd : FillRule;
    even_odd = 1_I32;
}

type LineCap = I32;

namespace LineCap {

    butt : LineCap;
    butt = 0_I32;

    round : LineCap;
    round = 1_I32;

    square : LineCap;
    square = 2_I32;
}

type LineJoin = I32;

namespace LineJoin {

    miter : LineJoin;
    miter = 0_I32;

    round : LineJoin;
    round = 1_I32;

    bevel : LineJoin;
    bevel = 2_I32;
}

type Operator = I32;

namespace Operator {

    clear : Operator;
    clear = 0_I32;

    source : Operator;
    source = 1_I32;

    over : Operator;
    over = 2_I32;

    in_ : Operator;
    in_ = 3_I32;

    out : Operator;
    out = 4_I32;

    atop : Operator;
    atop = 5_I32;

    dest : Operator;
    dest = 6_I32;

    dest_over : Operator;
    dest_over = 7_I32;

    dest_in : Operator;
    dest_in = 8_I32;

    dest_out : Operator;
    dest_out = 9_I32;

    dest_atop : Operator;
    dest_atop = 10_I32;

    xor : Operator;
    xor = 11_I32;

    add : Operator;
    add = 12_I32;

    saturate : Operator;
    saturate = 13_I32;

    multiply : Operator;
    multiply = 14_I32;

    screen : Operator;
    screen = 15_I32;

    overlay : Operator;
    overlay = 16_I32;

    darken : Operator;
    darken = 17_I32;

    lighten : Operator;
    lighten = 18_I32;

    color_dodge : Operator;
    color_dodge = 19_I32;

    color_burn : Operator;
    color_burn = 20_I32;

    hard_light : Operator;
    hard_light = 21_I32;

    soft_light : Operator;
    soft_light = 22_I32;

    difference : Operator;
    difference = 23_I32;

    exclusion : Operator;
    exclusion = 24_I32;

    hsl_hue : Operator;
    hsl_hue = 25_I32;

    hsl_saturation : Operator;
    hsl_saturation = 26_I32;

    hsl_color : Operator;
    hsl_color = 27_I32;

    hsl_luminosity : Operator;
    hsl_luminosity = 28_I32;
}

type PatternType = I32;

namespace Pattern {

    solid : PatternType;
    solid = 0_I32;

    surface : PatternType;
    surface = 1_I32;

    linear : PatternType;
    linear = 2_I32;

    radial : PatternType;
    radial = 3_I32;

    mesh : PatternType;
    mesh = 4_I32;

    raster_source : PatternType;
    raster_source = 5_I32;
}

type Overlap = I32;

namespace Overlap {

    in_ : Overlap;
    in_ = 0_I32;

    out : Overlap;
    out = 1_I32;

    part : Overlap;
    part = 2_I32;
}

type SubpixelOrder = I32;

namespace SubpixelOrder {

    default : SubpixelOrder;
    default = 0_I32;

    rgb : SubpixelOrder;
    rgb = 1_I32;

    bgr : SubpixelOrder;
    bgr = 2_I32;

    vrgb : SubpixelOrder;
    vrgb = 3_I32;

    vbgr : SubpixelOrder;
    vbgr = 4_I32;
}

type HintStyle = I32;

namespace HintStyle {

    default : HintStyle;
    default = 0_I32;

    none : HintStyle;
    none = 1_I32;

    slight : HintStyle;
    slight = 2_I32;

    medium : HintStyle;
    medium = 3_I32;

    full : HintStyle;
    full = 4_I32;
}

type HintMetrics = I32;

namespace HintMetrics {

    default : HintMetrics;
    default = 0_I32;

    off : HintMetrics;
    off = 1_I32;

    on : HintMetrics;
    on = 2_I32;
}

type FontType = I32;

namespace FontType {

    toy : FontType;
    toy = 0_I32;

    ft : FontType;
    ft = 1_I32;

    win32 : FontType;
    win32 = 2_I32;

    quartz : FontType;
    quartz = 3_I32;

    user : FontType;
    user = 4_I32;
}

type TextClusterFlags = U32;

namespace TextClusterFlags {

    backward : TextClusterFlags;
    backward = 1_U32;
}

type Extend = I32;

namespace Extend {

    none : Extend;
    none = 0_I32;

    repeat : Extend;
    repeat = 1_I32;

    reflect : Extend;
    reflect = 2_I32;

    pad : Extend;
    pad = 3_I32;
}

type Filter = I32;

namespace Filter {

    fast : Filter;
    fast = 0_I32;

    good : Filter;
    good = 1_I32;

    best : Filter;
    best = 2_I32;

    nearest : Filter;
    nearest = 3_I32;

    bilinear : Filter;
    bilinear = 4_I32;

    gaussian : Filter;
    gaussian = 5_I32;
}